<!doctype html><html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>lecture 4</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="styles.css" type="text/css" />
</head>
<body><div class="main"><div class="tree">
<p><strong>Index</strong></p>
<p><a href="cs306.html">cs306</a></p>

<ol>
<li><a href="cs306--lectures.html">lectures</a></li>
<ol>
<li><a href="cs306--lectures--lecture_1.html">lecture 1</a></li>
<li><a href="cs306--lectures--lecture_2.html">lecture 2</a></li>
<li><a href="cs306--lectures--lecture_3.html">lecture 3</a></li>
<li><a href="cs306--lectures--lecture_4.html">lecture 4</a></li>
<li><a href="cs306--lectures--lecture_5.html">lecture 5</a></li>
</ol>
<li><a href="cs306--algorithms.html">algorithms</a></li>
<ol>
<li><a href="cs306--algorithms--Block_Cipher_Modes.html">Block Cipher Modes</a></li>
<ol>
<li><a href="cs306--algorithms--Block_Cipher_Modes--ECB.html">ECB</a></li>
<li><a href="cs306--algorithms--Block_Cipher_Modes--CBC.html">CBC</a></li>
<ol>
<li><a href="cs306--algorithms--Block_Cipher_Modes--CBC--Chained_CBC.html">Chained CBC</a></li>
</ol>
<li><a href="cs306--algorithms--Block_Cipher_Modes--OFB.html">OFB</a></li>
<li><a href="cs306--algorithms--Block_Cipher_Modes--CTR.html">CTR</a></li>
</ol>
<li><a href="cs306--algorithms--Stream_Cipher_Modes.html">Stream Cipher Modes</a></li>
<li><a href="cs306--algorithms--Encryption.html">Encryption</a></li>
<ol>
<li><a href="cs306--algorithms--Encryption--One_Time_Pad.html">One Time Pad</a></li>
<li><a href="cs306--algorithms--Encryption--classical_ciphers.html">classical ciphers</a></li>
<ol>
<li><a href="cs306--algorithms--Encryption--classical_ciphers--Subsitution_Cipher.html">Subsitution Cipher</a></li>
<ol>
<li><a href="cs306--algorithms--Encryption--classical_ciphers--Subsitution_Cipher--Mono-alphabetic_substituion_cipher.html">Mono-alphabetic substituion cipher</a></li>
</ol>
<li><a href="cs306--algorithms--Encryption--classical_ciphers--Caesar's_Cipher.html">Caesar's Cipher</a></li>
<ol>
<li><a href="cs306--algorithms--Encryption--classical_ciphers--Caesar's_Cipher--Shift_Cipher.html">Shift Cipher</a></li>
<li><a href="cs306--algorithms--Encryption--classical_ciphers--Caesar's_Cipher--Vigenere_cipher.html">Vigenere cipher</a></li>
</ol>
</ol>
<li><a href="cs306--algorithms--Encryption--Substitution_Boxes.html">Substitution Boxes</a></li>
<li><a href="cs306--algorithms--Encryption--DES.html">DES</a></li>
<li><a href="cs306--algorithms--Encryption--AES.html">AES</a></li>
</ol>
<li><a href="cs306--algorithms--Pseudo_randomness.html">Pseudo randomness</a></li>
<ol>
<li><a href="cs306--algorithms--Pseudo_randomness--Linear_congruential_generator.html">Linear congruential generator</a></li>
</ol>
<li><a href="cs306--algorithms--MAC.html">MAC</a></li>
<ol>
<li><a href="cs306--algorithms--MAC--Fixed_Length.html">Fixed Length</a></li>
<li><a href="cs306--algorithms--MAC--Domain_extension.html">Domain extension</a></li>
<li><a href="cs306--algorithms--MAC--CBC.html">CBC</a></li>
</ol>
<li><a href="cs306--algorithms--Authenticated_encryption.html">Authenticated encryption</a></li>
<ol>
<li><a href="cs306--algorithms--Authenticated_encryption--Encrypt-and-authenticate.html">Encrypt-and-authenticate</a></li>
<li><a href="cs306--algorithms--Authenticated_encryption--Authenticate-then-encrypt.html">Authenticate-then-encrypt</a></li>
<li><a href="cs306--algorithms--Authenticated_encryption--Encrypt-then-authenticate.html">Encrypt-then-authenticate</a></li>
</ol>
<li><a href="cs306--algorithms--Hashes.html">Hashes</a></li>
<ol>
<li><a href="cs306--algorithms--Hashes--Constructing.html">Constructing</a></li>
<ol>
<li><a href="cs306--algorithms--Hashes--Constructing--Merkle-Damgard.html">Merkle-Damgard</a></li>
<li><a href="cs306--algorithms--Hashes--Constructing--Davies-Meyer.html">Davies-Meyer</a></li>
</ol>
<li><a href="cs306--algorithms--Hashes--Functions.html">Functions</a></li>
<ol>
<li><a href="cs306--algorithms--Hashes--Functions--MD5.html">MD5</a></li>
<li><a href="cs306--algorithms--Hashes--Functions--SHA1.html">SHA1</a></li>
<li><a href="cs306--algorithms--Hashes--Functions--SHA2.html">SHA2</a></li>
<li><a href="cs306--algorithms--Hashes--Functions--SHA3.html">SHA3</a></li>
</ol>
</ol>
</ol>
<li><a href="cs306--Labs.html">Labs</a></li>
<ol>
<li><a href="cs306--Labs--Lab_3.html">Lab 3</a></li>
</ol></ol></div>
<div class="page"><h1><b><u>lecture 4</u></b></h1><h2>Possible Eavesdropping Attacks</h2><br />• An attacker may posses a collection of ciphertext:<br />   ◇ ciphertext only attack<br />   ◇ EAV-attack<br />• An attacker may posses a collection of plaintext/ciphertext pairs for plaintexts selected by the attacker<br />   ◇ Chosen plaintext attack<br />   ◇ CPA-attack<br /><br /><h2>Perfect EAV-security</h2><br />• Definitions<br />    • For every D<sub>M</sub>, m ∈ M and c ∈ C, for which Pr[C=c] &gt; 0, it holds that Pr[M=m | C=c] = Pr[M=m]<br />    • C is independent of M<br />       ◇ For every m, m' ∈ M and c ∈ C, it holds that Pr[Enc<sub>k</sub>(m) = c] = Pr[Enc<sub>k</sub>(m') = c]<br />    • indistinguishability<br />       ◇ For every A, it holds that Pr[b'=b] = 1/2<br />• Absolutely no information is leaked about the plaintext<br />• To adversaries that unlimited computational power<br />• require that m<sub>0</sub>, m<sub>1</sub> are chosen by a PPT adversary<br />• require that no PPT adverasary can distinguish Enc<sub>k</sub>(m<sub>0</sub>) from Enc<sub>k</sub>(m<sub>1</sub>)<br /><br /><h2>Computational security</h2><br />• A tiny amount of information is leaked about the plaintext<br />• To adversaries with bounded computational power<br />• Attacks best strategy remains ineffective<br />   ◇ Random guess on secret key<br />   ◇ Exhaustive search over key space (brute force attack)<br />• Negligible functions:<br />   ◇ negl = very small probability of success of the attack<br />   ◇ can be ignored<br /><br /><h2>Computational EAV-security</h2><br />• require that m<sub>0</sub>, m<sub>1</sub> are chosen by a PPT adversary<br />• no PPT adversary can distinguish Enc<sub>k</sub>(m<sub>0</sub>) frp, Enc<sub>k</sub>(m<sub>1</sub>)<br />   ◇ Pr[b' = b] = 1/2 + negl<br /><br /><h2>CPA-security</h2><br />• Π = {M, (Gen, Enc, Dec)}<br />• (Enc, Dec) is CPA-secure if any PPT adversary guesses b correctly with probability at most 0.5 + ε(n), where ε is a negligible function<br />• Any encryption scheme that is CPA-secure is also CPA-secure for multiple encryptions<br />• CPA security implies probabilistic encryption<br />• EAV-security for multiple messages implies probabilistic encryption<br /><br />~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br /><br /><h2>Pseudo-randomness</h2><br />• not truly random in that<br />   ◇ derived by a deterministic algorithm<br />   ◇ output is dependent on initial values<br />• Two types: Classical PRGs, Cryptographically secure PRGs<br />• Classical PRGs - linear congruential generator<br />• Cryptographically secure PRGs  - Blum-Micali generator<br />• Definition<br />   ◇ Deterministic PPT algorithm G that on inpout a seed s ∈ {0,1}<sup>n</sup>, outputs G(s) ∈ {0,1}<sup>l/n</sup><br />   ◇ G is a PRG if:<br />      ▪ Expansion<br />         - for polynomial l, it holds that for any n, l(n) &gt; n<br />         - models the process of extracting randomness from a short random string<br />      ▪ Pseudorandomness<br />         - no efficient statistical test can tell apart G(s) from a truly random string r<br /><img src="images\22-1.png" alt="images\22-1.png" /><br /><br /><h2>Linear congruential generator</h2><br />• X<sub>i</sub> = ax<sub>i-1</sub> + b mod m i &gt;= 1 where<br />   ◇ x<sub>0</sub>  is the seed or start value<br />   ◇ a is the multiplier<br />   ◇ b is the increment<br />   ◇ m is the modulus<br />• Output:<br />   ◇ (x1, x2, ..., xk)<br />   ◇ y<sub>i</sub> = x<sub>i</sub> mod 2<br />   ◇ Y = (y1y2...yk) &lt;- pseudo random sequence of k bits<br /><h3>Example</h3><br />• x<sub>n</sub> = 3x<sub>n-1</sub> + 5 mod 31, n &gt;= 1, x<sub>0</sub> = 2<br />• 3 and 31 are relatively prime, one-to-one<br />• 31 is prime, order is 30<br />• 2,11,7,26,21,6,23,12,10,4,17,25,18,28,27,24,15,19,0,5,20,3,14,16,22,9,1,8,29,30<br />• When x<sub>0</sub> = 2, 01101010001<br />• When x<sub>1</sub> = 3 10001101001<br /><h3>Security</h3><br />• Fast, but insecure<br />   ◇ sensitive to the choice of parameters a, b, and m<br />   ◇ correlation between successive values<br />   ◇ short period, often m = 2<sup>32</sup> or 2<sup>64</sup><br />• Used commonly in compilers - rand()<br />• Not suitable for high-quality randomness<br />• Not suitable for cryptographic applications<br /><br /><h2>PRG security</h2><br />• Pr[D(G(s)) = 1] - Pr[D(r)=1] | &lt;= negl(n)<br /><br /><h2>PRG-based symmetric-key encryption scheme</h2><br />• encryption scheme is EAV-secure as long as the underlying PRG is secure<br />• either fixed-length or arbitrary-length encryption scheme<br /><img src="images\22-2.png" alt="images\22-2.png" /><br /><br /><h2>Modes of operation for stream ciphers</h2><br />• on-the-fly computation of new pseudorandom bits, no IV needed, EAV-security<br /> <img src="images\22-3.png" alt="images\22-3.png" /><br />• random IV used for every new message is sent along with ciphertext, CPA-security<br /><br /><h2>Pseudorandom functions</h2><br />• Generalize the concept of a PRG<br />   ◇ produce pseudorandom bits that also depend on specific input<br />   ◇ keyed functions of the form F<sub>k</sub>: {0,1}<sup>n</sup> -&gt; {0,1}<sup>n</sup><br />• Operate essentially as a random function<br />• F<sub>k</sub> is PRF if it is indistinguishable from a truly random function f [e.g. f is a random permutation]<br />• f: {0,1}<sup>n</sup> -&gt; {0,1}<sup>n</sup> is randomly selected for the set of all length-preserving functions mapping n-bit inputs to n-bit outputs<br />• <img src="images\22-4.png" alt="images\22-4.png" /><br /><br /><h2>PRF Security</h2><br />• Pr[D<sup>F(k,)</sup>(1<sup>n</sup>) = 1] - Pr[D<sup>f()</sup>(1<sup>n</sup>) = 1] | &lt;= negl(n)<br /><br /><h2>PRF-based symmetric-key encryption scheme</h2><br />• Encryption scheme is EAV-secure as long as the underlying PRG is secure<br />• Fixed-length encryption scheme<br /><img src="images\22-5.png" alt="images\22-5.png" /><br /><br />~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br /><br /><h2>Modes of Operations for block ciphers</h2><br /><h3>ECB - electronic code book</h3><br />• insecure<br />• deterministic - not CPA secure<br />• not EAV-secure<br /><img src="images\22-6.png" alt="images\22-6.png" /><br /><br /><h3>CBC - Cipher block chaining</h3><br />• CPA-secure if F<sub>k</sub> is a permutation<br />• uniform IV - otherwise security breaks<br /><img src="images\22-7.png" alt="images\22-7.png" /><br /><br /><h3>Chained CBC</h3><br />• Uses last block ciphertext as IV of next message<br />• not CPA-secure<br /><br /><h3>OFB - Output Feedback</h3><br />• IV uniform<br />• message length doesn't need to be multiple of n<br />• resembles synchronizes stream-cipher mode<br />• stateful variant (chaining) is secure<br />• CPA-secure if F<sub>k</sub> is PRF<br /><img src="images\22-8.png" alt="images\22-8.png" /><br /><br /><h3>CTR - Counter Mode</h3><br />• CTR uniform<br />• message length doesn't need to be multiple of n<br />• resembles synchronized stream-cipher mode<br />• CPA-secure if F<sub>k</sub> is PRF<br />• no need for F<sub>k</sub> to be invertible<br />• parallelizable<br /><img src="images\22-9.png" alt="images\22-9.png" /><br /><br /><h2>Additional Notes</h2><br />• Block length matters -&gt; IV or ctr can be recycled<br />• IV are often misused<br />   ◇ reused or not uniformly random<br />   ◇ CBC is a better option than OFB/CTR<br /><br />~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br /><br /><h2>Security problems studied by modern cryptography</h2><br />• Classical cryptography - message encryption<br />   ◇ provide secrecy/confidentiality<br />   ◇ no message should be leaked while in transit<br />• Modern cryptography - wide variety of security problems<br />   ◇ secrecy is not the only security concern when using an unprotected channel<br />   ◇ need to study large set of secrutiy properties<br />• Sibling of message encryption - message authentication<br />   ◇ provide integrity<br />   ◇ while in transit, no message should be modified by an outsider<br /><br /><h2>Message Authentication</h2><br />• Information has value -&gt; citrical information must be protected not to leak to unauthorized parties<br />   ◇ message encryption takes care of this<br />• Correct information is valuable<br />   ◇ incorrect or falsified information may be of little value<br />   ◇ random information may be useless<br />   ◇ maliciously crafted information can be harmful<br />   ◇ message authentication takes care of this<br /><br /><h3>Examples of attacks</h3><br />• A bank receives an electronic request to transfer money from user A to B<br />   ◇ Did A actually send the request?<br />• A user puchases from Amazon<br />   ◇ Did the user actually make the purchase?<br /><br /><h2>Integrity of communications / computations</h2><br />• no unprotected system can be assumed to be trustworthy<br />   ◇ origin of information (source) - attacks: impersonation, phishing, etc<br />   ◇ contents of information - attacks: man-in-the-middle, email spam, etc<br />• prevention vs detection<br />   ◇ tampering with information cannot be avoided. <br />   ◇ need to be detectable<br />• Goal: prevent undetected tampering<br /><br /><h2>Symmetric-key message authentication</h2><br />• Sign message m with tag t and send (m, t)<br />• Verify authenticity of received m using t<br /><h3>Applications</h3><br />• Secure communication<br />   ◇ verify authenticity of messages<br />   ◇ assumption<br />      ▪ securely generate distrbute and store shared key k<br />      ▪ attack does not learn key k<br />• Secure Storage<br />   ◇ verify authenticity of files<br />   ◇ assumption<br />      ▪ securely generate and store key k<br />      ▪ attacker does not learn key k<br /><br /><h2>Symmetric-key message authentication code (MAC)</h2><br />• defined by triplet of PPT algorithms (Gen, Mac, Vrfy) security parameter 1<sup>n</sup><br />   ◇ Gen: prob. alg. on input 1<sup>n</sup>, outputs a key k from the key space K<br />   ◇ Mac: prob. alg. on input message m ∈ {0,1}* and key k, outputs tag t, Mac<sub>k</sub>(m) -&gt; t<br />   ◇ Vrfy: det. alg. on input a pair (m, t) and key k, outputs a bit b, b := Vrfy<sub>k</sub>(m, t)<br />• Satisfying desired properties:<br />   ◇ efficiency: key generation and tag computation / verification are fast<br />   ◇ correctness: for all m, k it holds that Vrfy<sub>k</sub>(m Mac<sub>k</sub>(m)) = 1<br />   ◇ security: one cannot forge a verifiable pair (m, t)<br />• Authenicating m  = computing t<br />• Verifying authenticity of m = running vrfy<br /><br /><h2>Security of MACs</h2><br />• attacker cannot forge a verifiable message-tag pair (m, t)<br />• Replay attack -&gt; insert a new message m*, t* into traffic so that (m*, t*) is verifiable.<br />   ◇ if m* = previously observed message, attack is successful<br />• Brute-force attack Mac<sub>k</sub>(m) -&gt; t is publicly known<br />   ◇ An exhaustive search in key space K can be done to find the used key k<br />• new messages may be forged undetectably, but they can be found only with negligible probability or after an exponentially large computation<br />• replay-attack unsafe security definition<br />   ◇ better not to assume any semantics regarding the high-level app, but instead delegate the validity or safeety check to this app that consumes the messages<br />• Eliminating replay attacks<br />   ◇ Use of counters between sender and receiver<br />   ◇ Use of timestamps along with an authentication window for validation<br /><br />~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br /><br /><h2>MAC constructions</h2><br />• Fixed-length MAC<br />   ◇ direct application of a PRF for tagging<br />   ◇ limited applicability<br />• Domain extension for MACs<br />   ◇ straightforward secure extension of fix-length MAC<br />   ◇ inefficient<br />• CBC-MAC<br />   ◇ resembles CBC-mode encryption<br />   ◇ efficient<br /><br /><h2>Fixed-length MAC</h2><br />• Based on use of a PRF<br />   ◇ employ a PRF F<sub>k</sub> in the obvious way to compute and canonically verify tags<br />   ◇ set tag t to be the pseudorandom string derived by evaluating F<sub>k</sub> on message m<br />• secure, provided that F<sub>k</sub> is a secure PRF<br />• MAC scheme Π<br />   ◇ Gen(1<sup>n</sup>): {0, 1}<sup>n</sup> -&gt; k<br />   ◇ Mac<sub>k</sub>(m): set t = F<sub>k</sub>(m)<br />   ◇ Vrfy<sub>k</sub>(m, t): return 1 iff t = F<sub>k</sub>(m)<br /><img src="images\22-10.png" alt="images\22-10.png" /><br /><br /><h2>Domain extension for MACs</h2><br />• Based on previous fix-length MAC scheme Π<br />• Split up m into multiple d blocks m<sub>i</sub>.<br />• Pad them and authenticate via Π<br />• Reordering attack -&gt; verify the block index i<br />• Truncation attack -&gt; verify message length δ = |m|<br />• Mix-and-match attack -&gt; randomize tags (using message specific fresh nonce)<br />• F<sub>k</sub>(r || m<sub>i</sub> || i || δ)<br />• secure provided that F<sub>k</sub> is a secure PRF<br /><img src="images\22-11.png" alt="images\22-11.png" /><br />   <br /><h2>CBC-MAC</h2><br />• Employ a PRF similar to CBC-mode encryption<br />• security<br />   ◇ secure only when fixed-length messages are authenticated provided that F<sub>k</sub> is a secure PRF<br />   ◇ messages of length equal to any multiple of n can be authenticated<br />      ▪ length needs to be fixed in advance<br />   ◇ insecure otherwise<br />• Can authenticate longer messages than basic PRF-based scheme<br />• more efficient than domain-extension MAC scheme<br />• CBC-MAC uses no IV (or uses IV set to 0)<br />• Only uses last PRF output<br /><img src="images\22-12.png" alt="images\22-12.png" /><br /><br />~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br /><br /><h2>Authenticated encryption</h2><br />• Communication is over an open/unprotected channel<br />• No message should be leaked<br />• No message should be modified<br />• Encryption schemes provide secrecy/confidentiality<br />• MAC schemes provide integrity/unforability<br /><br /><h2>Secrecy vs Integrity</h2><br />• Secrecy<br />   ◇ sensitive information has value<br />      ▪ leaking it can be risky<br />   ◇ prevention<br />      ▪ does not imply integrity<br />• Integrity<br />   ◇ correct information has value<br />      ▪ if manipulated, it can be harmful<br />   ◇ detection<br />      ▪ does nont imply secrecy<br /><br /><h2>Authenticated encryption constructions</h2><br />• CPA-secure encryption scheme Π<sub>E</sub>=(Enc, Dec)<br />• a secure MAC Π<sub>M</sub> = (MAC, Vrfy)<br />• instantiated using independent secret keys k<sub>e</sub>, k<sub>m</sub><br />• order matters<br /><br /><h3>Encrypt-and-authenticate</h3><br />• Enc<sub>ke</sub>(m) -&gt; c; Mac<sub>km</sub>(m) -&gt; t; send ciphertext (c, t)<br />• if Dec<sub>ke</sub>(c) ≠ fail and Vrfy<sub>km</sub>(m,t) accepts<br />   ◇ output m<br />   ◇ else output fail<br />• Insecure<br />   ◇ MAC tag t may leak information about m<br />   ◇ if MAC is deterministic (CBC-MAC) then Π<sub>AE</sub> is not CPA-secure<br /><br /><h3>Authenticate-then-encrypt</h3><br />• Mac<sub>km</sub>(m) -&gt; t; Enc<sub>ke</sub>(m||t) -&gt; c; send ciphertext c<br />• if Dec<sub>ke</sub>(c) = m || t ≠ fail and Vrfy<sub>km</sub>(m,t) accepts,<br />   ◇ output m<br />   ◇ else output fail<br />• insecure<br /><br /><h3>Encrypt-then-authenticate</h3><br />• Enc<sub>ke</sub>(m) -&gt; c; Mac<sub>km</sub>(c) -&gt;t; send ciphertext (c, t)<br />• if Vrfy<sub>km</sub>(c,t) accepts then<br />   ◇ output Dec<sub>ke</sub>(c) = m,<br />   ◇ else output fail<br />• secure scheme as long as Π<sub>M</sub> is a strong MAC<br /><br /><h2>Application of Authenticated Encryption</h2><br />• Session communication<br />   ◇ Π<sub>AE</sub> = (Enc, Dec) enables 2 parties to communicate securely<br />   ◇ session: period of time during which sender and receiver maintain state<br />   ◇ idea: send message m as c = Enc<sub>k</sub>(m) and ignore received c that doesn't verify<br />   ◇ secrecy and integrity is protected<br />• Possible attacks:<br />   ◇ reordering attack - counters can be used to eliminate reordering/replays<br />   ◇ reflection attack - directional bit can be used to eliminate reflections<br />   ◇ replay attack - c = Enc<sub>k</sub>(b<sub>a-&gt;b</sub> || ctr<sub>A,b</sub> || m); ctr<sub>A,B</sub>++<br /><br />~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br /><br /><h2>Hash Functions</h2><br />• maps objects to a fix-length string<br />• core property: avoid collisions<br />   ◇ collision: distinct objects x ≠ y) are mapped to the same hash value (H(x) = H(y))<br />   ◇ collisions may exist, but they should be infeasbile to find<br />• lies between symmetric and assymetric key cryptography<br />• catpure different security properties on idealized random functions<br />• qualitative stronger assumption than PRF<br />• security parameter 1<sup>n</sup><br />• <img src="images\22-13.png" alt="images\22-13.png" /><br />• general hash function H<br />   ◇ maps a message of an arbitrary length to l(n)-bit string<br />• compression hash function h<br />   ◇ maps long binary string to a shorter binary string<br />   ◇ maps l'(n)-bit string to a l(n)-bit string with l'(n) &gt; l(n)<br /><br /><h2>Collision resistance (CR)</h2><br />• H is collision-resistant if no PPT adversary can find collisions non-negligibly often<br /><br /><h2>Security</h2><br />• Given a hash function H: X-&gt;Y<br />   ◇ preimage resistant (one-way)<br />      ▪ if given y ∈ Y, finding a value x ∈ X s.t. H(x) = y happens negligibly often<br />   ◇ 2nd preimage resistant (weak collision resistant)<br />      ▪ if given a uniform x ∈ X, finding a value x' ∈ X, s.t. x' ≠ x and H(x') = H(x) happens negligibly often<br />   ◇ cf collision resistant (strong collision resistant)<br />      ▪ if finding two distinct values x', x ∈ X, s.t. H(x') = H(x) happens negligibly often<br /><br /><h2>Merkle-Damgard transform</h2><br />• reduces problem to design of CR compression functions<br />• use for general hash functions<br />• general design pattern for cryptographic hash functions<br />• reduces collision resistance of general hash functions to colission resistance of compression functions<br />• compressing 1 single bit is at least as hard as compressing by any number of bits<br />• Design<br />   ◇ suppose that h: {0,1}<sup>2n</sup> -&gt; {0,1}<sup>n</sup> is a collision reistant compression function<br />   ◇ the general hash function M: {x: |x|&lt;2<sup>n</sup>} -&gt; {0,1}<sup>n</sup> is defined as<br />      ▪ H(x) is computed by applying h(x) in a chained manner over n-bit message blocks<br />         - pad x and create B message blocks x<sub>1</sub>....x<sub>B</sub> with |x<sub>i</sub>| = n<br />         - set extra final message block x<sub>B+1</sub> as n-bit encoding L of |x|<br />         - starting with z<sub>0</sub>=IV = 0<sup>n</sup>, output H(x) = z<sub>B+1</sub>, where z<sub>i</sub>=h<sup>s</sup>(z<sub>i-1</sub> || x<sub>i</sub>)<br />• If compression function h is collision resistant, then the derived hash function H is also collision resistant<br /><img src="images\22-14.png" alt="images\22-14.png" /><br /><br /><h2>Davies-Meyer Scheme</h2><br />• Generic construction of CR compression function<br />   ◇ assume PRF w/ key length n and block length l<br />   ◇ define h: {0, 1}<sup>n+l</sup> -&gt; {0,1}<sup>l</sup> as <br />      ▪ H(x) = F<sub>k</sub>(x) ⊕ x<br />   ◇ h is CR if F is an ideal cipher<br /><img src="images\22-15.png" alt="images\22-15.png" /><br /><br /></div></div>
</body></html>