<!doctype html><html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>lecture 3</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="styles.css" type="text/css" />
</head>
<body><div class="main"><div class="tree">
<p><strong>Index</strong></p>
<p><a href="cs306.html">cs306</a></p>

<ol>
<li><a href="cs306--lectures.html">lectures</a></li>
<ol>
<li><a href="cs306--lectures--lecture_1.html">lecture 1</a></li>
<li><a href="cs306--lectures--lecture_2.html">lecture 2</a></li>
<li><a href="cs306--lectures--lecture_3.html">lecture 3</a></li>
<li><a href="cs306--lectures--lecture_4.html">lecture 4</a></li>
<li><a href="cs306--lectures--lecture_5.html">lecture 5</a></li>
</ol>
<li><a href="cs306--algorithms.html">algorithms</a></li>
<ol>
<li><a href="cs306--algorithms--Block_Cipher_Modes.html">Block Cipher Modes</a></li>
<ol>
<li><a href="cs306--algorithms--Block_Cipher_Modes--ECB.html">ECB</a></li>
<li><a href="cs306--algorithms--Block_Cipher_Modes--CBC.html">CBC</a></li>
<ol>
<li><a href="cs306--algorithms--Block_Cipher_Modes--CBC--Chained_CBC.html">Chained CBC</a></li>
</ol>
<li><a href="cs306--algorithms--Block_Cipher_Modes--OFB.html">OFB</a></li>
<li><a href="cs306--algorithms--Block_Cipher_Modes--CTR.html">CTR</a></li>
</ol>
<li><a href="cs306--algorithms--Stream_Cipher_Modes.html">Stream Cipher Modes</a></li>
<li><a href="cs306--algorithms--Encryption.html">Encryption</a></li>
<ol>
<li><a href="cs306--algorithms--Encryption--One_Time_Pad.html">One Time Pad</a></li>
<li><a href="cs306--algorithms--Encryption--classical_ciphers.html">classical ciphers</a></li>
<ol>
<li><a href="cs306--algorithms--Encryption--classical_ciphers--Subsitution_Cipher.html">Subsitution Cipher</a></li>
<ol>
<li><a href="cs306--algorithms--Encryption--classical_ciphers--Subsitution_Cipher--Mono-alphabetic_substituion_cipher.html">Mono-alphabetic substituion cipher</a></li>
</ol>
<li><a href="cs306--algorithms--Encryption--classical_ciphers--Caesar's_Cipher.html">Caesar's Cipher</a></li>
<ol>
<li><a href="cs306--algorithms--Encryption--classical_ciphers--Caesar's_Cipher--Shift_Cipher.html">Shift Cipher</a></li>
<li><a href="cs306--algorithms--Encryption--classical_ciphers--Caesar's_Cipher--Vigenere_cipher.html">Vigenere cipher</a></li>
</ol>
</ol>
<li><a href="cs306--algorithms--Encryption--Substitution_Boxes.html">Substitution Boxes</a></li>
<li><a href="cs306--algorithms--Encryption--DES.html">DES</a></li>
<li><a href="cs306--algorithms--Encryption--AES.html">AES</a></li>
</ol>
<li><a href="cs306--algorithms--Pseudo_randomness.html">Pseudo randomness</a></li>
<ol>
<li><a href="cs306--algorithms--Pseudo_randomness--Linear_congruential_generator.html">Linear congruential generator</a></li>
</ol>
<li><a href="cs306--algorithms--MAC.html">MAC</a></li>
<ol>
<li><a href="cs306--algorithms--MAC--Fixed_Length.html">Fixed Length</a></li>
<li><a href="cs306--algorithms--MAC--Domain_extension.html">Domain extension</a></li>
<li><a href="cs306--algorithms--MAC--CBC.html">CBC</a></li>
<li><a href="cs306--algorithms--MAC--Hashing.html">Hashing</a></li>
<ol>
<li><a href="cs306--algorithms--MAC--Hashing--Insecure.html">Insecure</a></li>
<li><a href="cs306--algorithms--MAC--Hashing--HMAC.html">HMAC</a></li>
</ol>
</ol>
<li><a href="cs306--algorithms--Authenticated_encryption.html">Authenticated encryption</a></li>
<ol>
<li><a href="cs306--algorithms--Authenticated_encryption--Encrypt-and-authenticate.html">Encrypt-and-authenticate</a></li>
<li><a href="cs306--algorithms--Authenticated_encryption--Authenticate-then-encrypt.html">Authenticate-then-encrypt</a></li>
<li><a href="cs306--algorithms--Authenticated_encryption--Encrypt-then-authenticate.html">Encrypt-then-authenticate</a></li>
</ol>
<li><a href="cs306--algorithms--Hashes.html">Hashes</a></li>
<ol>
<li><a href="cs306--algorithms--Hashes--Constructing.html">Constructing</a></li>
<ol>
<li><a href="cs306--algorithms--Hashes--Constructing--Merkle-Damgard.html">Merkle-Damgard</a></li>
<li><a href="cs306--algorithms--Hashes--Constructing--Davies-Meyer.html">Davies-Meyer</a></li>
</ol>
<li><a href="cs306--algorithms--Hashes--Functions.html">Functions</a></li>
<ol>
<li><a href="cs306--algorithms--Hashes--Functions--MD5.html">MD5</a></li>
<li><a href="cs306--algorithms--Hashes--Functions--SHA1.html">SHA1</a></li>
<li><a href="cs306--algorithms--Hashes--Functions--SHA2.html">SHA2</a></li>
<li><a href="cs306--algorithms--Hashes--Functions--SHA3.html">SHA3</a></li>
</ol>
<li><a href="cs306--algorithms--Hashes--Applications.html">Applications</a></li>
<ol>
<li><a href="cs306--algorithms--Hashes--Applications--MAC.html">MAC</a></li>
<ol>
<li><a href="cs306--algorithms--Hashes--Applications--MAC--Insecure.html">Insecure</a></li>
<li><a href="cs306--algorithms--Hashes--Applications--MAC--HMAC.html">HMAC</a></li>
</ol>
<li><a href="cs306--algorithms--Hashes--Applications--Cloud_Storage.html">Cloud Storage</a></li>
<ol>
<li><a href="cs306--algorithms--Hashes--Applications--Cloud_Storage--Plain.html">Plain</a></li>
<li><a href="cs306--algorithms--Hashes--Applications--Cloud_Storage--Secure.html">Secure</a></li>
<ol>
<li><a href="cs306--algorithms--Hashes--Applications--Cloud_Storage--Secure--whole_file.html">whole file</a></li>
<li><a href="cs306--algorithms--Hashes--Applications--Cloud_Storage--Secure--separate_file.html">separate file</a></li>
<li><a href="cs306--algorithms--Hashes--Applications--Cloud_Storage--Secure--merkle_tree.html">merkle tree</a></li>
</ol>
</ol>
<li><a href="cs306--algorithms--Hashes--Applications--Digital_Envelops_-_Commitment_Schemes.html">Digital Envelops / Commitment Schemes</a></li>
<li><a href="cs306--algorithms--Hashes--Applications--Forward-secure_key_rotation.html">Forward-secure key rotation</a></li>
<li><a href="cs306--algorithms--Hashes--Applications--File_Identifiers.html">File Identifiers</a></li>
</ol>
</ol>
</ol>
<li><a href="cs306--attacks.html">attacks</a></li>
<li><a href="cs306--Labs.html">Labs</a></li>
<ol>
<li><a href="cs306--Labs--Lab_3.html">Lab 3</a></li>
</ol>
<li><a href="cs306--homework.html">homework</a></li>
</ol></div>
<div class="page"><h1><b><u>lecture 3</u></b></h1><h2>Shannon's theorem</h2><br />• Let Π = {M, (Gen, Enc, Dec)} be an encryption scheme with a message space M for which |M| = |K| = |C|. Then Π is perfectly secure if and only if:<br />1. Every key k ∈ K is chosen with equal probability 1/|K| by algorithm Gen<br />2. For every m ∈ M and every c ∈ C, these exists a unique key k ∈ K such that Enc<sub>k</sub>(m) outputs c<br /><br /><h2>Computational Security - Relax Perfectness</h2><br />• Perfect secrecy / security requires<br />   ◇ absolutely no information is leaked about the plaintext<br />   ◇ to adversaries that unlimited computational power<br />• Computational security<br />   ◇ A tiny amount of information is leaked about the plaintext (e.g.  w/ prob 2<sup>-60</sup>)<br />   ◇ To adversaries with bounded computational power (e.g. attack invests 200 yrs)<br />• Two relaxations<br />   ◇ Security is guaranteed against efficient adversaries<br />      ▪ Attacker must invest a sufficiently large resources<br />   ◇ Adversaries can potentially succeed<br />      ▪ Small probability of breakability<br /><h3>• Definition</h3><br />   ◇ Bounds the maximum success probability fo any (randomized) adversary running for some specified amount of time or investing a specified amount of resources<br />   ◇ A scheme is (t, ε)-secure if any adversary A, running for time at most t, succeeds in breaking the scheme with probability at most ε.<br />   ◇ need to define:<br />      ▪ what it means for an adverary to break a scheme<br />      ▪ specify precisely the resources<br /><br /><h2>Almost optimal security</h2><br />• Key length n, key space size |K| = 2<sup>n</sup><br />• parameter c models advanced computing methods (concurrency, multiple threads, etc)<br />• A running for time t succeeds with probability at most ct/2<sup>n</sup><br />• Like brute-forcing<br />• Today's recommendations<br />   ◇ n = 128<br /><br /><h2>Alternative Approach</h2><br />• Asymptotic approach<br />   ◇ secure parameter n is used (key length)<br />   ◇ efficient adversaries are equiated with probabilistic poly-time (PPT) algorithms that run for time that is a polynomial of n<br />   ◇ small probability of success is equated with success probabilities that are asymptotically smaller than any inverse polynomial in n<br />   ◇ A scheme is secure if any PPT adversary A succeeds in breaking the scheme with at most negligible probability<br /><br />~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br /><br /><h2>Classical Ciphers</h2><br />• based on letter substitution<br />• message space M is valid words from a given alphabet<br />• encryption<br />   ◇ ciphertext is produced by mapping each plaintext character into another character<br />   ◇ a character mpaaing is typically defined as a shift of a plaintext character by a number of positions in a canonical ordering of the characters in the alphabet<br />   ◇ character shifting occurs with wrap-around (mod 25 addition)<br />• decryption<br />   ◇ under shifting of characters with wrap-around (using mod 25 subtraction)<br /><br /><h3>Substituion cipher</h3><br /><img src="images\9-1.png" alt="images\9-1.png" /><br />• Each letter is uniquely replaced by another<br />• Broken by using a frequency analysis<br /><img src="images\9-2.png" alt="images\9-2.png" /><br /><br /><h3>Caesar's cipher</h3><br />• Shift each character in the message by 3 postiions (13 in ROT-13)<br />• no secret key is used - security by obscurity<br />• Brute force attacks - only 26 possibilities<br /><br /><h3>Shift Cipher</h3><br />• Key extension of Caesar's cipher<br />• Randomly set key k in [0:25]<br />   ◇ shift each character in the message by k positions<br />• Brute force attacks - only 26 possibilities - manual<br />• Automated attack based on statistics<br />   ◇ if a character i in the alphabet has a frequency p<sub>i</sub>, then from known statistics we know that Σ<sub>i</sub>p<sub>i</sub><sup>2</sup> ≈ 0.065<br />• The brute-force attack can test all possible keys<br />   ◇ condition becomes much simpler and isn't as manual<br /><br /><h3>Mono-alphabetic substituion cipher</h3><br />• generalization of shift cipher<br />• key space defines permutation on alphabet<br />   ◇ use a 1-1 mapping between characters in the alphabet to produce ciphertext<br />   ◇ shift each distinct character in the plaintext to get a distinct character in the ciphertext<br />• Key space is large (26! or 2<sup>88</sup>)<br />• character mapping is fixed - plaintext and ciphertext exhibit same statistics<br /><br /><h3>Vigenere cipher</h3><br />• generalization of mono-alphabetic substitution cipher<br />• key space defines fixed (shift) mapping that is applied on block of characters<br />• a key k is a string of length t, defining the shift for blocks of size t<br />• e.g. k = (2,1,3,11). Each block is shifted respectively by 2,1,3,11<br />• plaintext-to-ciphertext mapping is many-to-many<br />• if the key length t is known: problem is reduced to attacking the shift cipher<br />   ◇ statistical attacks for each subsequence of the from c<sub>j</sub>, c<sub>j+t</sub>, c<sub>j+2t</sub>...<br />• if key length t is unknown:<br />   ◇ repeat stastical attacks for gussed values of t.<br />   ◇ Kasiski's method: identify repeated patterns of length 2 or 3 in the ciphertext.p period t can be decuded by locations of these patterns in the text<br />   ◇ index of coincidence method: compute S<sub>T</sub> = Σ<sub>i</sub>q<sub>i</sub><sup>2</sup> and stop when S<sub>T</sub>  = 0.065. T is a multiple of t.<br /><br />~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br /><br /><h2>Stream Ciphers</h2><br /><img src="images\9-3.png" alt="images\9-3.png" /><br /><br /><h2>Block Ciphers</h2><br /><img src="images\9-4.png" alt="images\9-4.png" /><br /><br /><h2>Stream vs Block ciphers</h2><br /><img src="images\9-5.png" alt="images\9-5.png" /><br /><br /><h2>Perfect encryption of a block</h2><br />• Goal: encrypt a block of n bits using the same key all the time<br />• Approach: encryption via a bijective random mapping T from {0,1}<sup>n</sup> to {0,1}<sup>n</sup><br />   ◇ Mapped pairs are computed uniformly at random<br />• Problem: T has size ~ n 2<sup>n</sup><br />• Make it randomized<br />   ◇ pick random r and encrypt x as: (y = T[r]  XOR x, r)<br />   ◇ decrypt (y,r) as: y XOR T[r]<br /><br /><h2>Primitive techniques for symmetric-key encryption</h2><br />• Substitution<br />   ◇ exchanging one set of bits for another set<br />• Transposition<br />   ◇ rearranging the order of the ciphertext bits<br />• Confusion<br />   ◇ enforcing complex functional relationship between the plaintext/key pair and the ciphertext<br />• Diffusion<br />   ◇ distributes information from single plaintext characters over entire ciphertext output<br /><br /><h2>Substitution boxes</h2><br /><img src="images\9-6.png" alt="images\9-6.png" /><br /><br /><h2>DES: Data Encryption Standard</h2><br />• Block cipher<br />• Considered insecure<br /><img src="images\9-7.png" alt="images\9-7.png" /><br />• Employs substituion and transposition on top of each other for 16 rounds<br />• block size = 64 bits, key size = 56 bits<br />• double DES -&gt; not effective -&gt; 80 bit security<br />• triple DES -&gt; more effective -&gt;  112 bit security<br /><img src="images\9-8.png" alt="images\9-8.png" /><br /><br /><h2>AES: Advanced Encryption System</h2><br />• Block cipher<br />• Still in use<br /><img src="images\9-9.png" alt="images\9-9.png" /><br />• Employs substitution, confusion, and diffusion<br />   ◇ on blocks of 128 bits in 10, 12, or 14 rounds for keys of 128, 192, 256<br /><img src="images\9-10.png" alt="images\9-10.png" /><br /><br /><h2>DES vs AES</h2><br /><img src="images\9-11.png" alt="images\9-11.png" /><br /><br />~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br /><br /><h2>Block Cipher Modes</h2><br />• Describe the way a block cipher encrypts or decrypts a sequence of message blocks<br /><br /><h3>ECB: Electronic Code Book</h3><br />• Block P[i] encrypted into ciphertext block C[i] = E<sub>k</sub>(P[i])<br />• Block P[i] decrypted into ciphertext block M[i] = D<sub>k</sub>(C[i])<br /><img src="images\9-12.png" alt="images\9-12.png" /><br />• Strengths<br />   ◇ Simple<br />   ◇ Parallel encryptions<br />   ◇ Tolerates loss or damage<br />• Weaknesses<br />   ◇ Documents and images are not suitable since patterns in the plaintext are repeated in the ciphertext<br /><img src="images\9-13.png" alt="images\9-13.png" /><br /><br /><h3>CBC: Cipher Block Chaining</h3><br />• ECB produces the same ciphertext on the same ciphertext under the same key<br />• The ciphertext of the previous block can be mixed with the plaintext of the current block (XOR). an initial vector is used as the initial ciphertext<br />• Previous ciphertext block is combined with current plaintext block C[i] = E<sub>k</sub>(C[i-1]⊕P[i])<br />• C[-1] = IV; a random block separately transmitted encrypted<br />• decryption: P[i] = C[i-1]⊕D<sub>k</sub>(C[i])<br /><img src="images\9-14.png" alt="images\9-14.png" /><br /><br /></div></div>
</body></html>