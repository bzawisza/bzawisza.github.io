<!doctype html><html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>lecture 6</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="styles.css" type="text/css" />
</head>
<body><div class="main"><div class="tree">
<p><strong>Index</strong></p>
<p><a href="cs306.html">cs306</a></p>

<ol>
<li><a href="cs306--lectures.html">lectures</a></li>
<ol>
<li><a href="cs306--lectures--lecture_1.html">lecture 1</a></li>
<li><a href="cs306--lectures--lecture_2.html">lecture 2</a></li>
<li><a href="cs306--lectures--lecture_3.html">lecture 3</a></li>
<li><a href="cs306--lectures--lecture_4.html">lecture 4</a></li>
<li><a href="cs306--lectures--lecture_5.html">lecture 5</a></li>
<li><a href="cs306--lectures--lecture_6.html">lecture 6</a></li>
</ol>
<li><a href="cs306--Notes.html">Notes</a></li>
<ol>
<li><a href="cs306--Notes--Block_Cipher_Modes.html">Block Cipher Modes</a></li>
<ol>
<li><a href="cs306--Notes--Block_Cipher_Modes--ECB.html">ECB</a></li>
<li><a href="cs306--Notes--Block_Cipher_Modes--CBC.html">CBC</a></li>
<ol>
<li><a href="cs306--Notes--Block_Cipher_Modes--CBC--Chained_CBC.html">Chained CBC</a></li>
</ol>
<li><a href="cs306--Notes--Block_Cipher_Modes--OFB.html">OFB</a></li>
<li><a href="cs306--Notes--Block_Cipher_Modes--CTR.html">CTR</a></li>
</ol>
<li><a href="cs306--Notes--Stream_Cipher_Modes.html">Stream Cipher Modes</a></li>
<li><a href="cs306--Notes--Encryption.html">Encryption</a></li>
<ol>
<li><a href="cs306--Notes--Encryption--symmetric.html">symmetric</a></li>
<ol>
<li><a href="cs306--Notes--Encryption--symmetric--One_Time_Pad.html">One Time Pad</a></li>
<li><a href="cs306--Notes--Encryption--symmetric--classical_ciphers.html">classical ciphers</a></li>
<ol>
<li><a href="cs306--Notes--Encryption--symmetric--classical_ciphers--Subsitution_Cipher.html">Subsitution Cipher</a></li>
<ol>
<li><a href="cs306--Notes--Encryption--symmetric--classical_ciphers--Subsitution_Cipher--Mono-alphabetic_substituion_cipher.html">Mono-alphabetic substituion cipher</a></li>
</ol>
<li><a href="cs306--Notes--Encryption--symmetric--classical_ciphers--Caesar's_Cipher.html">Caesar's Cipher</a></li>
<ol>
<li><a href="cs306--Notes--Encryption--symmetric--classical_ciphers--Caesar's_Cipher--Shift_Cipher.html">Shift Cipher</a></li>
<li><a href="cs306--Notes--Encryption--symmetric--classical_ciphers--Caesar's_Cipher--Vigenere_cipher.html">Vigenere cipher</a></li>
</ol>
</ol>
<li><a href="cs306--Notes--Encryption--symmetric--Substitution_Boxes.html">Substitution Boxes</a></li>
<li><a href="cs306--Notes--Encryption--symmetric--DES.html">DES</a></li>
<li><a href="cs306--Notes--Encryption--symmetric--AES.html">AES</a></li>
</ol>
<li><a href="cs306--Notes--Encryption--asymmetric.html">asymmetric</a></li>
<ol>
<li><a href="cs306--Notes--Encryption--asymmetric--hybrid_encryption.html">hybrid encryption</a></li>
<li><a href="cs306--Notes--Encryption--asymmetric--algorithms.html">algorithms</a></li>
<ol>
<li><a href="cs306--Notes--Encryption--asymmetric--algorithms--El_Gamal.html">El Gamal</a></li>
<li><a href="cs306--Notes--Encryption--asymmetric--algorithms--RSA.html">RSA</a></li>
</ol>
</ol>
</ol>
<li><a href="cs306--Notes--Pseudo_randomness.html">Pseudo randomness</a></li>
<ol>
<li><a href="cs306--Notes--Pseudo_randomness--Linear_congruential_generator.html">Linear congruential generator</a></li>
</ol>
<li><a href="cs306--Notes--Message_Authentication.html">Message Authentication</a></li>
<ol>
<li><a href="cs306--Notes--Message_Authentication--MAC.html">MAC</a></li>
<ol>
<li><a href="cs306--Notes--Message_Authentication--MAC--CBC.html">CBC</a></li>
<li><a href="cs306--Notes--Message_Authentication--MAC--Domain_extension.html">Domain extension</a></li>
<li><a href="cs306--Notes--Message_Authentication--MAC--Fixed_Length.html">Fixed Length</a></li>
<li><a href="cs306--Notes--Message_Authentication--MAC--Hashing.html">Hashing</a></li>
<ol>
<li><a href="cs306--Notes--Message_Authentication--MAC--Hashing--Insecure.html">Insecure</a></li>
<li><a href="cs306--Notes--Message_Authentication--MAC--Hashing--HMAC.html">HMAC</a></li>
</ol>
</ol>
<li><a href="cs306--Notes--Message_Authentication--Digital_Signatures.html">Digital Signatures</a></li>
<ol>
<li><a href="cs306--Notes--Message_Authentication--Digital_Signatures--Asymmetric-key_message_authentication.html">Asymmetric-key message authentication</a></li>
<li><a href="cs306--Notes--Message_Authentication--Digital_Signatures--RSA.html">RSA</a></li>
</ol>
</ol>
<li><a href="cs306--Notes--Authenticated_encryption.html">Authenticated encryption</a></li>
<ol>
<li><a href="cs306--Notes--Authenticated_encryption--Encrypt-and-authenticate.html">Encrypt-and-authenticate</a></li>
<li><a href="cs306--Notes--Authenticated_encryption--Authenticate-then-encrypt.html">Authenticate-then-encrypt</a></li>
<li><a href="cs306--Notes--Authenticated_encryption--Encrypt-then-authenticate.html">Encrypt-then-authenticate</a></li>
</ol>
<li><a href="cs306--Notes--Hashes.html">Hashes</a></li>
<ol>
<li><a href="cs306--Notes--Hashes--Constructing.html">Constructing</a></li>
<ol>
<li><a href="cs306--Notes--Hashes--Constructing--Merkle-Damgard.html">Merkle-Damgard</a></li>
<li><a href="cs306--Notes--Hashes--Constructing--Davies-Meyer.html">Davies-Meyer</a></li>
</ol>
<li><a href="cs306--Notes--Hashes--Functions.html">Functions</a></li>
<ol>
<li><a href="cs306--Notes--Hashes--Functions--MD5.html">MD5</a></li>
<li><a href="cs306--Notes--Hashes--Functions--SHA1.html">SHA1</a></li>
<li><a href="cs306--Notes--Hashes--Functions--SHA2.html">SHA2</a></li>
<li><a href="cs306--Notes--Hashes--Functions--SHA3.html">SHA3</a></li>
</ol>
<li><a href="cs306--Notes--Hashes--Applications.html">Applications</a></li>
<ol>
<li><a href="cs306--Notes--Hashes--Applications--MAC.html">MAC</a></li>
<ol>
<li><a href="cs306--Notes--Hashes--Applications--MAC--Insecure.html">Insecure</a></li>
<li><a href="cs306--Notes--Hashes--Applications--MAC--HMAC.html">HMAC</a></li>
</ol>
<li><a href="cs306--Notes--Hashes--Applications--Cloud_Storage.html">Cloud Storage</a></li>
<ol>
<li><a href="cs306--Notes--Hashes--Applications--Cloud_Storage--Plain.html">Plain</a></li>
<li><a href="cs306--Notes--Hashes--Applications--Cloud_Storage--Secure.html">Secure</a></li>
<ol>
<li><a href="cs306--Notes--Hashes--Applications--Cloud_Storage--Secure--whole_file.html">whole file</a></li>
<li><a href="cs306--Notes--Hashes--Applications--Cloud_Storage--Secure--separate_file.html">separate file</a></li>
<li><a href="cs306--Notes--Hashes--Applications--Cloud_Storage--Secure--merkle_tree.html">merkle tree</a></li>
</ol>
</ol>
<li><a href="cs306--Notes--Hashes--Applications--Digital_Envelops_-_Commitment_Schemes.html">Digital Envelops / Commitment Schemes</a></li>
<li><a href="cs306--Notes--Hashes--Applications--Forward-secure_key_rotation.html">Forward-secure key rotation</a></li>
<li><a href="cs306--Notes--Hashes--Applications--File_Identifiers.html">File Identifiers</a></li>
</ol>
</ol>
<li><a href="cs306--Notes--Attacks.html">Attacks</a></li>
<li><a href="cs306--Notes--Types_of_Security.html">Types of Security</a></li>
</ol>
<li><a href="cs306--Labs.html">Labs</a></li>
<ol>
<li><a href="cs306--Labs--Lab_1.html">Lab 1</a></li>
<li><a href="cs306--Labs--Lab_2.html">Lab 2</a></li>
<li><a href="cs306--Labs--Lab_3.html">Lab 3</a></li>
<li><a href="cs306--Labs--Lab_4.html">Lab 4</a></li>
<li><a href="cs306--Labs--Lab_5.html">Lab 5</a></li>
<li><a href="cs306--Labs--Lab_6.html">Lab 6</a></li>
</ol>
<li><a href="cs306--homework.html">homework</a></li>
</ol></div>
<div class="page"><h1><b><u>lecture 6</u></b></h1><h2>ymmetric Key Cryptography</h2><br />• Assumptions<br />   ◇ Adversary<br />      ▪ types of attacks<br />   ◇ trusted setup<br />      ▪ keys are distributed securely<br />      ▪ keys remain secret<br />   ◇ trust basis<br />      ▪ underlying primitives are secure<br />      ▪ PRG, PRF, CR-hashing<br />• Limitations<br />   ◇ securely obtain<br />      ▪ strong assumption to make<br />      ▪ requires secure channel for key distribution<br />      ▪ seems impossible for two parties having no prior trust relationship<br />      ▪ not easily justifiable to hold a prioi<br />   ◇ shared secret key<br />      ▪ challenging problem to solve<br />      ▪ requires too many keys for n parties to communicate<br />      ▪ too much risk to protect all secret keys<br />      ▪ revovation complexity<br /><h3>• 2 approaches to solve key distribution</h3><br />   ◇ designated secure channels<br />      ▪ physically protected<br />      ▪ e.g. sound proof room<br />   ◇ trusted party<br />      ▪ entities autorized to dstribute keys<br />      ▪ e.g. key distribution center<br /><br />~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br /><br /><h2>Public key (assymetric cryptography)</h2><br />• Goal: devise a cryptosystem where key management is more manageable<br />• idea: user-specific keys (that come in pairs)<br />   ◇ U<sub>pk</sub> is public<br />   ◇ U<sub>sk</sub> is private<br />• usage:<br />   ◇ employ public key for public tasks<br />   ◇ employ private key for sensitive tasks<br />• assumption: <br />   ◇ public key infrastructure PKI: public keys become securely available to users<br />   ◇ secret keys remain secret<br />   ◇ underlying primitives are secure<br /><img src="images\66-1.png" alt="images\66-1.png" /><br /><h3>Terms</h3><br />• asymmetric crypto = public-key crypto<br />• symmetric crypto = secret key crypto<br />• user's public-key pair = (user's public key, user's private key)<br />• user's private key = user's secret key<br />• pk = public key<br />• sk = secret key<br /><br /><h3>Encryption</h3><br />• Sender and receiver maintain different keys<br />• each user has two keys: public and private<br />• message encrypted by receiver's public key can only be decrypted by receiver's private key<br /><br /><h3>Digital signatures</h3><br />• Sender and receiver maintain different keys<br />• each user has two keys: public and private<br />• messages signed by sender's private key can be verified by sender's public key<br /><br /><h2>Public key pairs and user identities</h2><br />• A public-key pair of user U can be specific to a machine or application<br />• Gen is a key-generation algorithm to produce (U<sub>pk</sub>, U<sub>sk</sub>)<br />• Public-key pair is always attached to a user's identity<br />• associated with the user's identity<br /><br /><h2>Public-key infrastructure (PKI)</h2><br />• Setting<br />   ◇ a set of users produce their public-key pairs<br />   ◇ keys will be used by a public-key cryptosystem<br />      ▪ each private key is securely stored individually by the user owning the key<br />• Where are publish keys stored?<br />• How do they remain authenticated?<br />• PKI is a mechanism for the secure management of public keys<br />   ◇ challenging to achieve<br /><br />~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br /><br /><h2>Symmetric vs Asymmetric Crypto</h2><br /><table class="table"><col/><col/><col/><col/><col/><tr><th></th><th>Key Management</th><th>Assumptions</th><th>Primitives</th><th>Adversarial Sampling</th></tr><tr><td>Symmetric</td><td>Less scalable and risker</td><td>secret and authentic communication</td><td>generic assumptions</td><td>oracle access</td></tr><tr><td></td><td></td><td>secure storage</td><td>more efficient in practice</td><td></td></tr><tr><td>Asymmetric</td><td>more scalable and simpler</td><td>authenticity (PKI)</td><td>number-theoretic assumptions</td><td>public-key operations and oracle access</td></tr><tr><td></td><td></td><td>secure storage</td><td>less efficient in practice (2-3 o.o.m)</td><td></td></tr></table><br /><img src="images\66-2.png" alt="images\66-2.png" /><br /><br />~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br /><br /><h2>Public-key encryption</h2><br />• assumes trusted setup<br />   ◇ PKI (public keys are public) and secure storage (private keys remain private)<br />• Many parties can encrypt, but only one party can decrypt<br />• <img src="images\66-3.png" alt="images\66-3.png" /><br />• defined by message space M and triplet of algorithms (Gen, Enc, Dec)<br />   ◇ Gen: probabilistic algorithm that outputs a public-key pair (U<sub>pk</sub>, U<sub>sk</sub>) for user U<br />   ◇ Enc: probabilistic algorithm that on input plantextm  and public key, outputs ciphertext c<br />   ◇ Dec: deterministic alogirthm that on input ciphertext c and private key, outputs a plaintext m<br /><br /><h3>Security</h3><br />• CPA-securty -- randomized encryption is required<br />• Easy to check (U<sub>pk</sub>, U<sub>sk</sub>) is a valid key pair<br />• infeasible to produce U<sub>sk</sub> from U<sub>pk</sub><br />• the attacker can posses the rcipient's public key<br />   ◇ all 3 collapse to the same attack type<br />      ▪ ciphertext-only attack<br />      ▪ known plaintext attack<br />      ▪ chosen-plaintext attack<br />• EAV-security<br />   ◇ A scheme is EAV-secure if no PPT attacker can correctly guess b non-negligibly better than randomly guessing<br />      ▪ even when it can use the recipient's public key pk<br />      ▪ one message extends to multiple messages<br />      ▪ fixed-length messages extends to arbitrary length messages<br />      ▪ probabilistic encryption is necessary<br />• CPA-security<br />   ◇ A scheme is CPA-secure if any PPT adversary guesses b correctly with probability at most 0.5 + ε(n), where ε is a negligible function<br />      ▪ even when it learns the encryptions of messages of its choice<br />      ▪ one message extends to multiple messages<br />      ▪ fixed-length messages extends to arbitrary length messages<br />      ▪ probabilistic encryption is necessary<br />• EAV-security implies CPA-security<br />• CCA-security<br />   ◇ attacker posses recipient's public key<br />   ◇ attacker has access to the decryption oracle<br />   ◇ attacker is not allowed to use the oracle on the challenge ciphertext<br />   ◇ probabilistic encryption necessary<br />   ◇ one message extends to multiple messages<br />   ◇ fixed length messages DO NOT extend to arbitrary length messages<br /><br />~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br /><br /><h2>Hybrid encryption</h2><br /><img src="images\66-4.png" alt="images\66-4.png" /><br />• reduces public-key crypto to secret-key crypto<br />• better performance<br />• apply public-key encryption on random key k<br />• use k for secret-key encryption of m<br />•<img src="images\66-5.png" alt="images\66-5.png" /><br />• Using KEM/DEM approach<br />   ◇ encapsulate secret key k into c<br />   ◇ use k for secret-key encryption of m<br />   ◇ KEM: key-encapsulation mechanism - Encaps<br />   ◇ DEM: data encapsulation machanism - Enc'<br />   ◇ KEM/DEM scheme<br />      ▪ CPA-secure if KEM is CPA-secure and Enc' is EAV-secure<br />      ▪ CCA-secure if KEM and Enc' are CCA-secure<br /><br />~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br /><br /><h2>Digital Signatures</h2><br />• A person can deny that they signed something.<br />• Digital signatures make it infeasible to fake<br /><h3>• Mac for digital signing</h3><br />   ◇ two parties share a secret key k<br />   ◇ one party generates MAC on the message to be signed, using k<br />   ◇ message digest serves as a signature<br />   ◇ the other party varifies the integrity of the signed message using k<br />• <img src="images\66-6.png" alt="images\66-6.png" /><br /><br /><h3>Properties of Digital Signatures</h3><br />• Authentication - receiver can determine that the signature really came from the signer<br />• Integrity/unforgeability - no one other than the signer can produce the signature without the signer's private key<br />• Non-repudiation - the ability to ensrue that a party cannot deny the authenticity of their signature on a document<br />• Not alterable signatures - no signer, receiver, or any interceptor can modify the signature without tampering being evident<br />• Not reusable signatures (replay-attack safeness) - any attempt to reuse a previous signature will be detected by the receiver<br /><br /><h3>Asymmetric-key message authentication</h3><br />• Scheme<br />   ◇ Secret key is sued for signing and public key is used for verification<br />   ◇ The message m with signature σ is sent.<br />• One only party can sign, but multiple parties can verify<br />• Assumption: PKI<br />• existential unforgeability<br />   ◇ infeasible for any PPT attacker to forge an invalid but verifiable signature on a new message<br /><br />~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br /><br /><h2>Public Key Certifications</h2><br />• public-key pairs are bound to user identities<br />• PKI implements a mechanism for securely managing public keys<br />• Where to store keys so they are publicly available?<br />• How are they secured so they remain authenticated?<br />• Challenging to achieve:<br />   ◇ open, dynamic, multi-user system<br />      ▪ users can join or leave, or privileges can be revoked<br />   ◇ user-specific public-key pairs<br />      ▪ unique key pair is attached to the identity of user U<br />   ◇ authenticated public keys<br />      ▪ a user's current public key should be consistently known to everyone<br /><br /><h3>Distibution of public keys</h3><br />• public announcement<br />   ◇ users can distribute public keys to recipients or broadcast to community at large<br />• publicly available directory<br />   ◇ users can obtain better security by registering keys with a public directory<br /><br /><h3>Trusting One's Public Key</h3><br />• Attacks:<br />   ◇ An impostor claims to be a true party --- impostor has public and private key of victim<br />   ◇ Impostor sends impostor's own public key to the verifier --- impostor pretends to be victim<br /><br /><h3>Certificates</h3><br />• A digital certificate is a public key and an identity bound together and signed by a certificate authority<br />• a certificate authority is an authority that users trust to accurately verify identities before generating certificates that bind those identities to keys<br />• imperfect practice<br /><br /><h3>Certificate hierarchy</h3><br />• a single CA certifying every public key is impractical<br />• uses trusted root authorities<br />• root CA signs certificates for intermediate CAs and they sign certificates for lower-level CAs.<br />• <img src="images\66-7.png" alt="images\66-7.png" /><br /><br /><h2>X.509 certificates</h2><br />• framework for authentication services<br />   ◇ public keys stored as certificates in public directory<br />   ◇ certificates issued and signed by certification authority<br />• used by many applications - SSL<br /><br /><h2>Key Agreement</h2><br />• vulnerable to man in the middle attacks<br />   ◇ need to verify with the certificate authority<br />• Public key encryption<br />   ◇ <img src="images\66-8.png" alt="images\66-8.png" /><br />• Diffie-hellman key-agreement protocol<br />   ◇ computing discrete logs is computationally hard<br />   ◇ <img src="images\66-9.png" alt="images\66-9.png" /><br /><br />~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br /><br /><h2>Number-Theoretic Facts</h2><br />• Public key encryption algorithms<br />   ◇ typically based on number theory and modular arithmetic<br />   ◇ relies on hardness assumption<br />   ◇ Two algorithms:<br />      ▪ RSA<br />         - Based on the hardness of factoring large numbers<br />      ▪ El Gamal<br />         - Based on the hardness of solving discrete logarithm<br />         - Same idea as Diffie-Hellman key agreement<br /><br /><h3>Multiplicative inverses</h3><br />• x * y mod n = 1<br />• multiplicative inverses of the residues modulo 11<br />• <img src="images\66-10.png" alt="images\66-10.png" /><br />• Theorem<br />   ◇ An element x in Z<sub>n</sub> has a multiplicative inverse if and only if x and n are relatively prime.<br />• Z = 10<br />• <img src="images\66-11.png" alt="images\66-11.png" /><br />   ◇ If p is prime, every nonzero in Z<sub>p</sub> has multiplicative inverses<br /><br /><h3>Multiplicative group</h3><br />• all numbers up to n in Z<sub>n</sub> that have multiplicative inverses<br /><br /><h3>Totient function Φ(n)</h3><br />• denotes order (length) of Z*<sub>n</sub><br />• e.g. Z*<sub>10</sub> = {1,3,7,9). n = 10. Φ(10) = 4<br />• if n = p * q, where p and q are distinct primes, then<br />   ◇ Φ(n) = (p-1)(q-1)<br />   ◇ difficult problem to find p and q, or order of n, only given N<br /><br /><h3>Fermat's Little Theorem</h3><br />• for each nonzero x in Z<sub>p</sub>, x<sup>p-1</sup> mod p = 1<br />• e.g. p = 5<br />   ◇ 1<sup>4</sup> mod 5 = 1<br />   ◇ 3<sup>4</sup> mod 5 =1<br /><br /><h3>Euler's Theorem</h3><br />• for each element x in Z*<sub>n</sub>, x<sup>Φ(n)</sup> mod n =1<br />• e.g. n = 10<br />   ◇ Z*<sub>10</sub>= {1,3,7,9}. n = 10, Φ(10) = 4<br />   ◇ 3<sup>Φ(10)</sup> mod 10 = 1<br /><br /><h3>Computing Exponents</h3><br />• For the multiplicative group Z*<sub>n</sub>, we can reduce the exponent modulo Φ(n)<br />• x<sup>y</sup> mod n = x<sup>y mod Φ(n)</sup> mod n<br /><br /><h3>Euclid's GCD algorithm</h3><br />• gcd(a, b) = if b = 0 return a else gcd(b, a mod b);<br /><br /><h3>Extended Euclidean algorithm</h3><br /><img src="images\66-12.png" alt="images\66-12.png" /><br /><br /><h3>Computing multiplicative inverse</h3><br />• given two numbers a and b, there exist integers x, y s.t. x a + y b = gcd(a,b)<br />• can be computed efficiently by the extended Euclidean algorithm<br />• the multiplicative inverse of a in Z<sub>b</sub> exists iff gcd(a,b) = 1<br />• The extended Euclidean algorithm computes x and y s.t. xa + yb = 1<br />• the multiplicative inverse of a in Z<sub>b</sub> is x<br /><br /><h3>Powers</h3><br />• Let p be a prime<br />   ◇ the sequences of successive powers of the elements in Z*<sub>p</sub> exhibit repeating subsequences<br />   ◇ the sizes of the repeating subsequences and the number of their repetitions are the divisors of p-1<br /><img src="images\66-13.png" alt="images\66-13.png" /><br /><br />~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br /><br /><h2>RSA Algorithm</h2><br />General case<br />• Setup (run by a given user)<br />   ◇ n = p * q, with p and q primes<br />   ◇ e relatively prime to Φ(n) = (p - 1)(q - 1)<br />   ◇ d inverse of e in Z<sub>Φ(n)</sub><br />• Keys<br />   ◇ public key is K<sub>pk</sub> = (n, e)<br />   ◇ private key is K<sub>sk</sub> = d<br />• Encryption<br />   ◇ C = M<sup>e</sup> mod n for plaintext M in Z<sub>n</sub><br />• Decryption<br />   ◇ M = C<sup>d</sup> mod n<br /><img src="images\66-14.png" alt="images\66-14.png" /><br /><img src="images\66-15.png" alt="images\66-15.png" /><br /><br />~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br /><br /><h2>Signing with RSA</h2><br />• (M<sup>d</sup>)<sup>e</sup> = M mod p * q<br />• signing algorithm = Sign(M,d,n): σ = M<sup>d</sup> mod n for message M in Z<sub>n</sub><br />• verifying algorithm = Vrfy(σ, M, e, n): return M == σ<sup>e</sup> mod n<br />• General case<br />   ◇ Setup<br />      ▪ n = p * q with p and q primes<br />      ▪ e relatively prime to Φ(n) = (p - 1)(q - 1)<br />      ▪ d inverse of e in Z<sub>Φ(n)</sub><br />   ◇ Keys<br />      ▪ public key is K<sub>pk</sub> = (n,e)<br />      ▪ private key is K<sub>sk</sub> = d<br />   ◇ Sign<br />      ▪ σ = M<sup>d</sup> mod n for message M in Z<sub>n</sub><br />   ◇ Verify<br />      ▪ Check if M = σ<sup>e</sup> mod n<br /><img src="images\66-16.png" alt="images\66-16.png" /><br /><br /><h3>Security</h3><br />• Sign the hash<br />• Current practice is using 2048-bit long RSA keys (617 decimal digits)<br />• Plain RSA is deteministic<br />• homomorphic<br /><br /><h3>Issues</h3><br />• Requires various algorithms<br />   ◇ Generation of random numbers<br />   ◇ primality testing<br />   ◇ computation of the GCD<br />   ◇ Computation of the multiplicative inverse<br /><br /><h3>Real-world usage</h3><br />• Randomized RSA<br />   ◇ To encrypt message M under an RSA public key (e, n) generate a new random session AES key K, compute ciphertext as [K<sup>e</sup> mod n, AES<sub>k</sub>(m)]<br />   ◇ prevents an adversary distinguishing two encryptions of the same M since K is chosen at random every time encryption takes place<br />• Optimal Asymmetric Encryption Padding (OAEP)<br />   ◇ roughly to encrypt M , choose random r, encode M as M' = [X = M ⊕ H<sub>1</sub>(r), Y = r ⊕ H<sub>2</sub>(X)] where H<sub>1</sub> and H<sub>2</sub> are cryptographic hash functions, then encrypt it as (M')<sup>e</sup> mod n<br /><br /><h2>Modular Powers</h2><br /><img src="images\66-17.png" alt="images\66-17.png" /><br /><br /><h2>Pseudo-primality testing</h2><br /><img src="images\66-18.png" alt="images\66-18.png" /><br /><br />~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br /><br /><h2>ElGamal Encryption Scheme</h2><br /><img src="images\66-19.png" alt="images\66-19.png" /><br /><img src="images\66-20.png" alt="images\66-20.png" /></div></div>
</body></html>